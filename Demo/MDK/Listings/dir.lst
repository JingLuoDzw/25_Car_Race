C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE dir
OBJECT MODULE PLACED IN .\Objects\dir.obj
COMPILER INVOKED BY: D:\APP\Rubbish\c251\C251\BIN\C251.EXE ..\CODE\dir.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\C
                    -ODE;..\USER;..\..\lib\zf_app;..\..\lib\zf_base;..\..\lib\zf_bsp) DEBUG PRINT(.\Listings\dir.lst) TABS(2) OBJECT(.\Object
                    -s\dir.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          float temp = 0;
    3          //int sqt = 800,nsqt = 250;
    4          //uint16 position = 0;    //菜单箭头位置
    5          //int dapos = 0;    //数据位置
    6          //int da[2] = {900,250};
    7          
    8          
    9          extern char state[30];
   10          int pid_lead = 0;
   11          int Kp1[5]={350,500,  0,  0,  0}; //280.350   350.250   350.200.0.5一米二330稳定    350.220.0.7 360还好
   12          int Kp2[5]={200,180,  0,  0,  0};
   13          int Kd1[5]={0.5,0.5,  1,  1,  1};
   14          int Kd2[5]={0,  0,  0,  0,  0};
   15          void Dir_Loop(float error, float speed_goal, int flag)
   16          {
   17   1      
   18   1          if((state[state_lead]==Big_Circ_Left)||(state[state_lead]==Big_Circ_Right)||
   19   1            (state[state_lead]==Small_Circ_Left)||(state[state_lead]==Small_Circ_Left))
   20   1          {
   21   2              pid_lead = 0;
   22   2          }
   23   1          else if((state[state_lead]==Ramp))
   24   1          {
   25   2              pid_lead = 0;
   26   2          }
   27   1          else if((state[state_lead]==Obstacle))
   28   1          {
   29   2              pid_lead = 0;
   30   2          }
   31   1          else
   32   1              pid_lead = 0;
   33   1          
   34   1          dir_loop_pid.ek =  error;
   35   1          temp =  fabs(error) * Kp1[pid_lead]* dir_loop_pid.ek
   36   1                  + Kp2[pid_lead] * dir_loop_pid.ek
   37   1                  - Kd1[pid_lead] * imu660ra_gyro_z / 65.6
   38   1                  + Kd2[pid_lead] * (dir_loop_pid.ek - dir_loop_pid.ek_1);
   39   1      
   40   1          dir_loop_pid.ek_1 = dir_loop_pid.ek;
   41   1          
   42   1          motor_L_pid.SetValue = speed_goal - temp;
   43   1          motor_R_pid.SetValue = speed_goal + temp;
   44   1          
   45   1      //    motor_L_pid.SetValue = 50;
   46   1      //    motor_R_pid.SetValue = 50;
   47   1          
   48   1      //    if(error < -0.4)
   49   1      //    {
   50   1      //      motor_L_pid.SetValue = 1.5*speed_goal - temp;
   51   1      //      motor_R_pid.SetValue = 50;
   52   1      //    }else if(error > 0.4)
   53   1      //    {
   54   1      //      motor_L_pid.SetValue = 50;
   55   1      //      motor_R_pid.SetValue = 1.5*speed_goal + temp;
   56   1      //    }else if(error < -0.3)
   57   1      //    {
C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 2   

   58   1      //      motor_L_pid.SetValue = 1.2*speed_goal - temp;
   59   1      //      motor_R_pid.SetValue = 100;
   60   1      //    }else if(error > 0.3)
   61   1      //    {
   62   1      //      motor_L_pid.SetValue = 100;
   63   1      //      motor_R_pid.SetValue = 1.2*speed_goal + temp;
   64   1      //    }else
   65   1      //    {
   66   1      //      motor_L_pid.SetValue = speed_goal - temp;
   67   1      //      motor_R_pid.SetValue = speed_goal + temp;
   68   1      //    }
   69   1      
   70   1      //    if(fabs(error)>0.4)
   71   1      //    {
   72   1      //      motor_L_pid.SetValue = 110 - temp;
   73   1      //      motor_R_pid.SetValue = 110 + temp;
   74   1      //    }else if(fabs(error)>0.2)
   75   1      //    {
   76   1      //      motor_L_pid.SetValue = 135 - temp;
   77   1      //      motor_R_pid.SetValue = 135 + temp;
   78   1      //    }else
   79   1      //    {
   80   1      //      motor_L_pid.SetValue = speed_goal - temp;
   81   1      //      motor_R_pid.SetValue = speed_goal + temp;
   82   1      //    }
   83   1              
   84   1      }
*** WARNING C47 IN LINE 15 OF ..\CODE\dir.c: 'flag': unreferenced parameter
   85          
   86          
   87          
   88          //void Dir_Loop(float error, float speed_goal, int flag)
   89          //{
   90          ////  if(flag==0)
   91          ////  {
   92          ////
   93          ////  dir_loop_pid.KP=Kp_Select(error);
   94          ////      dir_loop_pid.ek =  error;
   95          ////   temp= dir_loop_pid.KP * dir_loop_pid.ek  +100*dir_loop_pid.ek
   96          ////  - imu660ra_gyro_z / 65.6
   97          ////  + dir_loop_pid.KD * (dir_loop_pid.ek - dir_loop_pid.ek_1)
   98          ////  ;
   99          ////  dir_loop_pid.ek_1=dir_loop_pid.ek;
  100          //// ;
  101          ////  }
  102          ////  else
  103          ////  printf("%f\r\n",error);
  104          //    {
  105          //        dir_loop_pid.KP = Kp_Select(error);
  106          //        dir_loop_pid.ek =  error;
  107          //        temp =  fabs(error) * 500 * dir_loop_pid.ek //800 200  /600 300
  108          //                + 300 * dir_loop_pid.ek
  109          //                - imu660ra_gyro_z / 65.6
  110          //                + dir_loop_pid.KD * (dir_loop_pid.ek - dir_loop_pid.ek_1);
  111          ////      printf("%f\r\n",error);
  112          //        dir_loop_pid.ek_1 = dir_loop_pid.ek;
  113          ////  temp=temp;
  114          //    }
  115          ////  printf("%f\r\n",temp);
  116          //    
  117          ////    if(speed_goal - temp > 2*speed_goal)
  118          ////        {motor_L_pid.SetValue =2*speed_goal;}
  119          ////        else
  120          ////    if(speed_goal + temp >2*speed_goal)
  121          ////        motor_R_pid.SetValue = 2*speed_goal;
  122          ////        else
C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 3   

  123          ////    if(speed_goal - temp <-1*speed_goal)
  124          ////        {motor_L_pid.SetValue =-1*speed_goal;}
  125          ////        else
  126          ////    if(speed_goal + temp <-1*speed_goal)
  127          ////        motor_R_pid.SetValue = -1*speed_goal;
  128          ////        else
  129          ////        {
  130          //          motor_L_pid.SetValue = speed_goal - temp;
  131          //          motor_R_pid.SetValue = speed_goal + temp;
  132          ////        }
  133          
  134          //}
  135          
  136          
  137          
  138          //void showmenu()
  139          //{
  140          //  if(P42 == 0)
  141          //  {
  142          //    position = position + 16;
  143          //    lcd_clear(WHITE);
  144          //    dapos++;
  145          //    delay_ms(50);
  146          //    if(position == 32)
  147          //    {
  148          //      position = 0;
  149          //      dapos = 0;
  150          //    }
  151          //  }
  152          //  if(P71 == 0)
  153          //  {
  154          //    position = position - 16;
  155          //    lcd_clear(WHITE);
  156          //    dapos--;
  157          //    delay_ms(50);
  158          //    if(position == -16)
  159          //    {
  160          //      position = 16;
  161          //      dapos = 1;
  162          //    }
  163          //  }
  164          //  if(P72 == 0)
  165          //  {
  166          //    da[dapos] = da[dapos] - 5;
  167          //    delay_ms(150);
  168          //    if(da[dapos] < 0)
  169          //    {
  170          //      da[dapos] = 0;
  171          //    }
  172          //  }
  173          //  if(P70 == 0)
  174          //  {
  175          //    da[dapos] = da[dapos] + 5;
  176          //    delay_ms(150);
  177          //  }
  178          //  lcd_showchar(50,position,'<');
  179          //}
  180          
  181          //void Dir_Loop(float error,float speed_goal,int flag)
  182          //{
  183          
  184          //if(flag==0)
  185          //{
  186          //  count++;
  187          //  if(count<60)
  188          //  {
C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 4   

  189          //      P67=1;
  190          //  }
  191          //  else
  192          //  {
  193          //      P67=0;
  194          //      count=0;
  195          //  }
  196          //
  197          //  dir_loop_pid.KP=Kp_Select_1(error);
  198          //}
  199          //else
  200          //{
  201          //  count=0;
  202          //  P67=0;
  203          //      dir_loop_pid.KP=Kp_Select(error);
  204          //}
  205          
  206          //  dir_loop_pid.ek =  error;
  207          //   temp= dir_loop_pid.KP* dir_loop_pid.ek
  208          ////    -imu660ra_gyro_z / 65.6
  209          //  + dir_loop_pid.KD * (dir_loop_pid.ek - dir_loop_pid.ek_1)
  210          //  ;
  211          //  dir_loop_pid.ek_1=dir_loop_pid.ek;
  212          //  motor_L_pid.SetValue=speed_goal-temp;
  213          //  motor_R_pid.SetValue=speed_goal+temp;
  214          //}
  215          
  216          
  217          
  218          
  219          
  220          
  221          
  222          float  Kp_Select(float error)
  223          {
  224   1          return fabs(error) * 50;
  225   1      //    if(error < 0.05 && error > -0.05) // section1
  226   1      //      return 150;
  227   1      //    else if(error < 0.1 && error > -0.1) // section2
  228   1      //      return 150;
  229   1      //    else if(error < 0.15 && error > -0.15) //3
  230   1      //          return 150;
  231   1      //    else if(error <0.2 && error > -0.2)
  232   1      //      return  150;
  233   1      //    else if(error < 0.25 && error > -0.25)
  234   1      //      return  150;
  235   1      //    else if(error <0.3 && error > -0.3)
  236   1      //      return 180;
  237   1      //    else if(error < 0.35 && error > -0.35)
  238   1      //          return 210;
  239   1      //    else if(error < 0.4 && error > -0.4)
  240   1      //      return 240;
  241   1      //    else if(error < 0.45 && error > -0.45)
  242   1      //      return 270;
  243   1      //    else if(error < 0.5 && error > -0.5)
  244   1      //      return 300;
  245   1      //    else if(error < 0.55 && error > -0.55)
  246   1      //      return 330;
  247   1      //    else
  248   1      //      { return 400;}
  249   1      }
  250          
  251          
  252          //void angle_loop()
  253          //{
  254          //  float angle_speed=0;
C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 5   

  255          //  angle_speed=(motor_R_pid.SetValue-motor_L_pid.SetValue)/15.5;
  256          //
  257          //}
  258          
  259          
  260          
  261          
  262          
  263          
  264          
  265          
  266          
  267          
  268          
  269          
  270          
  271          
  272          
  273          
  274          
  275          
  276          
  277          
  278          
  279          
  280          
  281          
  282          
  283          
  284          
  285          
  286          
  287          
  288          
  289          
  290          
  291          
  292          //void Dir_Loop(float error,float speed_goal)
  293          //{
  294          
  295          //  float inc=0;
  296          ////    dir_loop_pid.KP=Kp_Select(error)*0.6;
  297          //      dir_loop_pid.ActValue =  error;
  298          
  299          //      inc=PID_Control_Inc(&dir_loop_pid,1);
  300          //  if(inc>-3&&inc<3)
  301          //  {inc=0;}
  302          //      temp+=inc;
  303          //  dir_loop_pid.ek_1=dir_loop_pid.ek;
  304          ////temp=temp*0.6;
  305          ////    printf("%f\r\n",temp);
  306          ////    temp=temp>speed_goal?speed_goal:temp;
  307          ////    temp=temp<(0-speed_goal)?(0-speed_goal):temp;
  308          //  temp=temp>100?100:temp;
  309          //  temp=temp<(-100)?(-100):temp;
  310          //  motor_L_pid.SetValue=speed_goal+temp;
  311          //  motor_R_pid.SetValue=speed_goal-temp;
  312          //}


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       233     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
C251 COMPILER V5.60.0,  dir                                                                05/06/25  08:39:51  PAGE 6   

  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        46          2
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        70     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
