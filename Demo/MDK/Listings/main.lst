C251 COMPILER V5.60.0,  main                                                               05/06/25  17:43:15  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\APP\Rubbish\c251\C251\BIN\C251.EXE ..\USER\main.c XSMALL INTR2 WARNINGLEVEL(3) BROWSE INCDIR(..\
                    -CODE;..\USER;..\..\lib\zf_app;..\..\lib\zf_base;..\..\lib\zf_bsp) DEBUG PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Obje
                    -cts\main.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          int adc_value[8] = {0};   //八个电感值
    3          uint8 uart_delay = 0;   //while循环五次串口发送一次数据
    4          extern uint16 dl1b_distance_mm;
    5          extern float Sum_Distance;
    6          //  Track   Out   Small_Circ_Right  Small_Circ_Left
    7          char state[30] = {Track, Out, Track, Small_Circ_Left, Track, Small_Circ_Left, Track, Track, Track, Stop};
             -  //2025赛道元素顺序
    8          //速度
    9          int SPEED = 150;
   10          //转向环
   11          int Kp1[5]={ 350 , 0 , 0 , 0 , 0 }; //280.350   350.250   350.200.0.5一米二330稳定    350.220.0.7 360还好
   12          int Kp2[5]={ 200 , 0 , 0 , 0 , 0 };
   13          float Kd1[5]={ 0.5 , 0 , 0 , 0 , 0 };
   14          float Kd2[5]={ 0 , 0 , 0 , 0 , 0 };
   15          //左环电感判断条件
   16          int Circ_Jump_Left[4] = { 1000 , 1000 , 0 , 1000 };
   17          //左环状态判断条件
   18          int Circ_Left_Dis_Start = 10 ;
   19          int Circ_Left_Angle = 340 ;
   20          int Circ_Left_Dis_Final = 80 ;
   21          //左环行为
   22          int Circ_Left_Speed_L = 150 ;
   23          int Circ_Left_Speed_R = 250 ;
   24          int Circ_Left_Speed_Out = 150 ;
   25          //出库
   26          float Out_Jump_Angle = - 70 ;
   27          int Out_Speed_L = 250 ;
   28          int Out_Speed_R = 50 ;
   29          
   30          int Circ_Jump_Right[4] = { 1000 , 0 , 1000 , 1000 };
   31          int Circ_Right_Dis_Start = 10 ;
   32          int Circ_Right_Angle = - 340 ;
   33          int Circ_Right_Dis_Final = 80 ;
   34          int Circ_Right_Speed_L = 250 ;
   35          int Circ_Right_Speed_R = 150 ;
   36          int Circ_Right_Speed_Out = 150 ;
   37          
   38          int main()
   39          {
   40   1          board_init();
   41   1          pit_timer_ms(TIM_1, 5);
   42   1          printf("pit init\r\n");
   43   1          pit_timer_ms(TIM_4, 5);
   44   1          NVIC_SetPriority(TIMER1_IRQn, 2);
   45   1          NVIC_SetPriority(UART4_IRQn, 3);
   46   1          InitPID();
   47   1          EnableGlobalIRQ(); // 开启总中断
   48   1          printf("all init\r\n");
   49   1          printf("motor pid set value\r\n");
   50   1        
   51   1      //    pwm_duty(PWMA_CH4P_P66, 3000 );   //      引脚校正
   52   1      //    pwm_duty(PWMA_CH1P_P60, 3000 );   //右负
   53   1      //    pwm_duty(PWMA_CH3P_P64, 3000 );   //左正
   54   1      //    pwm_duty(PWMA_CH2P_P62, 3000 ); 
   55   1        
   56   1      //    motor_L_pid.SetValue = 0 ;
C251 COMPILER V5.60.0,  main                                                               05/06/25  17:43:15  PAGE 2   

   57   1      //    motor_R_pid.SetValue = 0 ;
   58   1          
   59   1          delay_ms(7000);
   60   1          start_0 = 1;
   61   1          
   62   1          while (1)     //正常循迹
   63   1          {
   64   2              if (TIM1_Flag)
   65   2              {
   66   3                  uart_delay++;
   67   3                  if (uart_delay > 4)
   68   3                  {
   69   4                      uart_delay = 0;
   70   4                    
   71   4      //                printf("%d,%d,%d,%d\r\n", adc_value[0], adc_value[1],
   72   4      //                                          adc_value[3], adc_value[4]);
   73   4                    
   74   4      //                printf("%f,%f,%f,%f\r\n", motor_L_pid.ActValue, motor_R_pid.ActValue,
   75   4      //                                          motor_L_pid.SetValueTmp, motor_R_pid.SetValueTmp);
   76   4                    
   77   4                  }
   78   3                  
   79   3                  P52 = 0;    //LED亮
   80   3                  imu660ra_get_gyro();    //陀螺仪
   81   3                  dl1b_get_distance();
   82   3                
   83   3                  state_detect(adc_value);
   84   3                
   85   3                  switch (state[state_lead])
   86   3                  {
   87   4                      case Track:
   88   4                          Track_Action(adc_value);
   89   4                          break;
   90   4                      case Out:
   91   4                          Out_Action();
   92   4                      case Big_Circ_Left:
   93   4                      case Small_Circ_Left:
   94   4                          Circ_Left_Action(adc_value);
   95   4                          break;
   96   4                      case Big_Circ_Right:
   97   4                      case Small_Circ_Right:
   98   4                          Circ_Right_Action(adc_value);
   99   4                          break;
  100   4                      case Obstacle:
  101   4                          Obstacle_Action();
  102   4                          break;
  103   4                      case Ramp:
  104   4                          Track_Action(adc_value);
  105   4                          break;
  106   4                      case Stop:
  107   4                          Stop_Action();
  108   4      //                case Left_Right_Angle:
  109   4      //                    Left_Right_Angle_Action(adc_value);
  110   4      //                case Right_Right_Angle:
  111   4      //                    Right_Right_Angle_Action(adc_value);
  112   4                  }
  113   3                          
  114   3      //            lcd_showint32(0,0,adc_value[0],4);
  115   3      //            lcd_showint32(0,1,adc_value[1],4);
  116   3      //            lcd_showint32(0,2,adc_value[3],4);
  117   3      //            lcd_showint32(0,3,adc_value[4],4);
  118   3                  
  119   3      //            lcd_showint16(0,5,imu660ra_gyro_z);
  120   3      //            lcd_showfloat(0,6,error,1,6);
  121   3                  
  122   3      //            lcd_showint32(0,4,adc_value[2],4);
C251 COMPILER V5.60.0,  main                                                               05/06/25  17:43:15  PAGE 3   

  123   3      //            lcd_showint32(0,5,Flag_Circ,4);
  124   3      //            lcd_showint32(0,6,Sum_Distance,4);
  125   3      //            lcd_showint32(0,7,(int)state_lead,4);
  126   3      //            lcd_showint32(0,8,(int)dl1b_distance_mm,4);
  127   3      
  128   3                  TIM1_Flag = 0;
  129   3                  P52 = 1;
  130   3              }
  131   2          }
  132   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       257     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       157     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       301     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
